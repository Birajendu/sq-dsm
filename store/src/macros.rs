//! Macros managing requests and responses.
//!
//! Our protocol uses the Result(T) type to communicate rich errors to
//! the client.  These macros deal with sending a request using the
//! asynchronous I/O framework Tokio, and decoding the result.
//!
//! This implementation uses macros instead of functions to interface
//! with the code stubs generated by the RPC compiler.

// Sends request and decodes result.
//
// Sends the given request and decodes the result.
macro_rules! make_request {
    ( $core: expr, $request: expr ) => {{
        use node::result::Which;

        let r: std::result::Result<Result<_>, capnp::Error> = $core.run(
            $request.send().promise
                .and_then(|response| {
                    let r = pry!(pry!(pry!(response.get()).get_result()).which());
                    let r = match r {
                        /* The Result.  */
                        Which::Ok(Ok(x)) => Ok(x),
                        Which::Err(Ok(e)) => Err(e.into()),
                        /* Protocol violations.  */
                        Which::Ok(Err(e)) => Err(e.into()),
                        Which::Err(Err(e)) => Err(e.into()),
                    };
                    Promise::ok(r)
                }));
        r?
    }}
}

macro_rules! make_stats_request {
    ( $core: expr, $request: expr ) => {{
        use node::result::Which;

        let r: std::result::Result<Result<_>, capnp::Error> = $core.run(
            $request.send().promise
                .and_then(|response| {
                    let r = pry!(pry!(pry!(response.get()).get_result()).which());
                    let r = match r {
                        /* The Result.  */
                        Which::Ok(Ok(s)) => Ok(Stats{
                            created: from_unix(s.get_created()),
                            updated: from_unix(s.get_updated()),
                            encryption: Stamps::new(s.get_encryption_count(),
                                                    s.get_encryption_first(),
                                                    s.get_encryption_last()),
                            verification: Stamps::new(s.get_verification_count(),
                                                      s.get_verification_first(),
                                                      s.get_verification_last()),
                        }),
                        Which::Err(Ok(e)) => Err(e.into()),
                        /* Protocol violations.  */
                        Which::Ok(Err(e)) => Err(e.into()),
                        Which::Err(Err(e)) => Err(e.into()),
                    };
                    Promise::ok(r)
                }));
        r?
    }}
}


macro_rules! make_request_map {
    ( $core: expr, $request: expr, $map: expr ) => {{
        use node::result::Which;

        let r: std::result::Result<Result<_>, capnp::Error> = $core.run(
            $request.send().promise
                .and_then(|response| {
                    let r = pry!(pry!(pry!(response.get()).get_result()).which());
                    let r = match r {
                        /* The Result.  */
                        Which::Ok(Ok(x)) => $map(x),
                        Which::Err(Ok(e)) => Err(e.into()),
                        /* Protocol violations.  */
                        Which::Ok(Err(e)) => Err(e.into()),
                        Which::Err(Err(e)) => Err(e.into()),
                    };
                    Promise::ok(r)
                }));
        r?
    }}
}

/// Behaves like try! for server functions.  Because it uses the
/// 'results' parameter, it must be bound explicitly.
macro_rules! bind_results {
    ( $results: ident ) => {
        #[allow(unused_macros)]
        macro_rules! fail {
            ( $expr:expr ) => {{
                eprintln!("{}:{}: {:?}", file!(), line!(), $expr);
                pry!($results.get().get_result()).set_err($expr);
                return Promise::ok(());
            }};
        }

        #[allow(unused_macros)]
        macro_rules! sry {
            ( $expr:expr ) => {{
                match $expr {
                    Ok(x) => x,
                    Err(x) => {
                        eprintln!("{}:{}: {:?}", file!(), line!(), x);
                        pry!($results.get().get_result()).set_err(x.into());
                        return Promise::ok(());
                    },
                }
            }};
        }
    };
}
